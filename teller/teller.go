package main

import (
	"github.com/chzyer/readline"
	"github.com/fatih/color"
	flags "github.com/jessevdk/go-flags"
	"github.com/pkg/errors"
	"log"
	"os"
	"os/signal"
	"strings"
	"net/http"

	erpc "github.com/Varunram/essentials/rpc"
	utils "github.com/Varunram/essentials/utils"
	consts "github.com/YaleOpenLab/opensolar/consts"
	core "github.com/YaleOpenLab/opensolar/core"
	solar "github.com/YaleOpenLab/opensolar/core"
	"github.com/spf13/viper"
)

// package teller contains the remote client code that would be run on the client's
// side and communicate information with us and with atonomi and other partners.
// that it belongs, the contract, recipient, and eg. person who installed it.
// Consider doing this with IoT partners, eg. Atonomi.

// Teller authenticates with the platform using a remote API and then retrieves
// credentials once authenticated. Both the teller and the project recipient on the
// platform are the same entity, just that the teller is associated with the hw device.
// hw device needs an id and stuff, hopefully Atonomi can give us that. Else, we have a deviceId
// generated using a crypto random soruce,  hopefully should be sufficient.

// Teller tracks whenever the device starts and goes off, so we know when exactly the device was
// switched off. This is enough as proof that the device was running in between. This also
// avoids needing to poll the blockchain often and saves on the (minimal, still) tx fee.

// Since we can't compile this directly on the raspberry pi, we need to cross compile the
// go executable and transfer it over to the raspberry pi:
// env GOOS=linux GOARCH=arm GOARM=5 go build
// advisable to build off the pi and transport the executable since I don't think we want to be running
// go get on a raspberry pi with the stellar dependencies.
// one should run an ipfs node on the raspberry pi to ensure the teller can commit to ipfs without relying
// on the platform

var opts struct {
	Daemon     bool   `short:"d" description:"Run the teller in daemon mode"`
	Port       int    `short:"p" description:"The port on which the teller runs on (default: 443)"`
	TestSwytch bool   `long:"ts" description:"Test swytch API workflow"`
	Url        string `short:"u" description:"The URL of the remote opensolar instance"`
}

var (
	// LocalRecipient is the recipient struct associated with the project the teller is installed for
	LocalRecipient core.Recipient
	// LocalProject is the project that the teller is associated with
	LocalProject solar.Project
	// LocalProjIndex contains the project index the teller is associated with
	LocalProjIndex string
	// LocalSeedPwd contains the seed password of a user
	LocalSeedPwd string
	// RecpSeed stores the seed and PublicKey for easy vanity use
	RecpSeed string
	// RecpPublicKey is the receipient's PublicKey used to authenticate the teller
	RecpPublicKey string
	// PlatformPublicKey contains the platform parameters for interfacing with the platform
	PlatformPublicKey string
	// PlatformEmail is the platform's email address
	PlatformEmail string
	// ApiUrl is the API of the remote opensolar instance
	ApiUrl string
	// DeviceId contains the device's id
	DeviceId string
	// DeviceLocation contains the device's location
	DeviceLocation string
	// DeviceInfo contains information on the user's device
	DeviceInfo string
	// StartHash records the blockhash when the teller starts and NowHash stores the blockhash at a particular instant
	StartHash string
	// NowHash is the hashchain has right now
	NowHash string
	// HashChainHeader is the header of the ipfs hash chain
	HashChainHeader string
	// SwytchUsername is the username that the teller has on the swytch platform
	SwytchUsername string
	// SwytchPassword is the password that the teller has on the swytch platform
	SwytchPassword string
	// SwytchClientid is the clientId associated with the given IoT Hub on swytch
	SwytchClientid string
	// SwytchClientSecret is the password associated with the given IoT Hub on swytch
	SwytchClientSecret string
	// AssetName is the asset for which this teller has been installed towards
	AssetName string
	// Token is the access token used to logon to the platform
	Token string
	// Username is the Username used to logon to any openx based platform
	Username string
	// Pwhash is the Pwhash used to logon to any openx based platform
	Pwhash string
	// Mapskey is the API key of google maps needed to store the location of the teller
	Mapskey string
	// client is the local client that can be configured to accept local certs generated by the user
	client *http.Client
)

var cleanupDone chan struct{}

func autoComplete() readline.AutoCompleter {
	return readline.NewPrefixCompleter(
		readline.PcItem("help",
			readline.PcItem("update"),
			readline.PcItem("ping"),
			readline.PcItem("receive"),
			readline.PcItem("display"),
			readline.PcItem("update"),
			readline.PcItem("qq"),
			readline.PcItem("hh"),
		),
		readline.PcItem("display",
			readline.PcItem("balance",
				readline.PcItem("xlm"),
				readline.PcItem("asset"),
			),
			readline.PcItem("info"),
		),
	)
}

func ParseConfig() error {
	var err error
	_, err = flags.ParseArgs(&opts, os.Args)
	if err != nil {
		log.Fatal("Failed to parse arguments / Help command")
	}

	viper.SetConfigType("yaml")
	viper.SetConfigName("config")
	viper.AddConfigPath(".")

	err = viper.ReadInConfig()
	if err != nil {
		return errors.Wrap(err, "Error while reading email values from config file")
	}

	requiredParams := []string{"platformPublicKey", "seedpwd", "username", "password", "apiurl", "mapskey", "projIndex", "assetName"}

	for _, param := range requiredParams {
		if !viper.IsSet(param) {
			return errors.New("required param: " + param + " not found")
		}
	}

	PlatformPublicKey = viper.GetString("platformPublicKey")
	LocalSeedPwd = viper.GetString("seedpwd")
	Username = viper.GetString("username")
	Pwhash = utils.SHA3hash(viper.GetString("password"))
	ApiUrl = viper.GetString("apiurl")
	Mapskey = viper.GetString("mapskey")
	AssetName = viper.GetString("assetName")
	SwytchUsername = viper.GetString("susername")
	SwytchPassword = viper.GetString("spassword")
	SwytchClientid = viper.GetString("sclientid")
	SwytchClientSecret = viper.GetString("sclientsecret")

	LocalProjIndex, err = utils.ToString(viper.GetInt("projIndex"))
	if err != nil {
		return err
	}

	if opts.Port == 0 {
		opts.Port = consts.Tlsport
	}
	if opts.TestSwytch {
		testSwytch()
	}
	if opts.Url != "" {
		ApiUrl = opts.Url
	}

	return nil
}

func main() {
	var err error
	erpc.SetConsts(30) // set rpc timeout to 30s to allow for slow connections wrt the blockchain and stuff.
	// might even need to extend it given some transactions like payback take longer
	err = ParseConfig()
	if err != nil {
		log.Fatal(err)
	}

	log.Println("---------------WELCOME TO THE TELLER INTERFACE---------------")
	defer recoverPanic() // catch any panics that may occur during the teller's runtime
	err = StartTeller()  // login to the platform, set device id, etc
	if err != nil {
		log.Fatal(err)
	}
	colorOutput("TELLER PUBKEY: "+RecpPublicKey, GreenColor)
	colorOutput("DEVICE ID: "+DeviceId, GreenColor)

	signalChan := make(chan os.Signal, 1)
	cleanupDone = make(chan struct{})
	signal.Notify(signalChan, os.Interrupt)

	StartHash, err = getLatestBlockHash()
	if err != nil {
		log.Fatal(err)
	}

	balance, err := getNativeBalance()
	if err != nil {
		log.Fatal(err)
	}

	log.Println("BALANCE: ", balance)
	log.Println("START HASH: ", StartHash)
	// run goroutines in the background to routinely check for payback, state updates and stuff
	go checkPayback()
	// go updateState()
	// go storeDataLocal()

	if opts.Daemon {
		log.Println("Running teller in daemon mode")
		go func() {
			<-signalChan
			log.Println("\nSigint received, calling endhandler!")
			err = endHandler()
			for err != nil {
				log.Println(err)
				err = endHandler()
				<-cleanupDone
			}
			os.Exit(1)
		}()

		startServer(opts.Port) // run a daemon and listen for connections
		return                 // shouldn't come here, even if it does, we should be good
	}

	// non daemon mode, CLI available.
	go func() {
		<-signalChan
		log.Println("\nSigint received, not quitting without closing endhandler!")
		close(cleanupDone)
	}()

	go startServer(opts.Port)

	promptColor := color.New(color.FgHiYellow).SprintFunc()
	whiteColor := color.New(color.FgHiWhite).SprintFunc()
	rl, err := readline.NewEx(&readline.Config{
		Prompt:       promptColor("teller") + whiteColor("# "),
		HistoryFile:  consts.TellerHomeDir + "/history.txt",
		AutoComplete: autoComplete(),
	})
	if err != nil {
		log.Fatal(err)
	}

	defer rl.Close()

	for {
		// setup reader with max 4K input chars
		msg, err := rl.Readline()
		if err != nil {
			err := endHandler() // error, user wants to quit
			for err != nil {
				log.Println(err)
				err = endHandler()
				<-cleanupDone // to prevent user from quitting when endhandler is running
			}
			break
		}
		msg = strings.TrimSpace(msg)
		if len(msg) == 0 {
			continue
		}
		rl.SaveHistory(msg)

		cmdslice := strings.Fields(msg)
		colorOutput("entered command: "+msg, YellowColor)

		ParseInput(cmdslice)
	}
}

// recoverPanic captures any unexpected panics that might occur and cause the teller to quit.
// even in such a situation, we would like to be warned so we can take some action
func recoverPanic() {
	if rec := recover(); rec != nil {
		err := rec.(error) // recover the panic as an error
		log.Println("unexpected error, invoking EndHandler", err)
		err = endHandler()
		for err != nil { // run this loop until all endhandler functions are called
			log.Println(err)
			err = endHandler()
			<-cleanupDone // to prevent user from quitting when endhandler is running
		}
		os.Exit(1)
	}
}
